# üîß Model Info Badge - Plano de Corre√ß√£o Segura

**üìÖ Data:** Janeiro 2025  
**üéØ Objetivo:** Implementar corre√ß√£o do Model Info Badge de forma incremental e segura  
**üìö Baseado em:** [Li√ß√µes Aprendidas](./model-info-badge-lessons-learned.md)  
**‚ö†Ô∏è Prioridade:** Zero breaking changes - corre√ß√£o gradual

## üö® Problema Identificado

**Situa√ß√£o Atual:**

- ‚úÖ Badge funciona inicialmente (mostra ‚úì verde)
- ‚ùå Ap√≥s mudan√ßa de modelo via ModelSelector + nova mensagem
- ‚ùå Badge n√£o atualiza para ‚úì verde (requer refresh manual)
- üîÑ Force re-fetch implementado, mas n√£o resolve completamente

**Causa Raiz (baseada nas li√ß√µes):**

- **Race condition** entre `useChat.onFinish` e atualiza√ß√£o de `lastMessageMetadata`
- **Missing callback chain** para notificar badge quando streaming termina
- **Timing issue** - badge calcula status antes dos dados serem atualizados

## üìê An√°lise da Arquitetura Atual

### **Fluxo de Dados Identificado:**

```mermaid
graph TD
    A[ModelSelector] --> B[handleModelSelect]
    B --> C[updateSessionMutation]
    C --> D[Force Re-fetch]
    D --> E[sessionQuery.refetch]
    E --> F[messagesQuery.refetch]
    F --> G[ModelInfoBadge re-render]

    H[User sends message] --> I[useChat streaming]
    I --> J[handleChatFinish]
    J --> K[syncNow + refetchSession]
    K --> L[??? Badge should update ???]
```

### **Problema Identificado:**

- ‚ùå **Gap**: N√£o h√° conex√£o entre `handleChatFinish` e `ModelInfoBadge`
- ‚ùå **Timing**: Badge calcula status antes de `lastMessageMetadata` ser atualizada
- ‚ùå **Missing callback**: Badge n√£o sabe quando streaming terminou

## üéØ Estrat√©gia de Corre√ß√£o: Callback Chain Pattern

**Baseado nas li√ß√µes aprendidas:** Implementar **callback chain** para notificar badge quando streaming termina.

### **Fluxo da Solu√ß√£o:**

```mermaid
graph TD
    A[useChat.onFinish] --> B[handleChatFinish]
    B --> C[onStreamingFinished callback]
    C --> D[UnifiedChatPage handler]
    D --> E[Force badge update]
    E --> F[Badge re-calculates status]
    F --> G[‚úÖ Green badge instantly]
```

## üìã Plano de Implementa√ß√£o - 5 Etapas Seguras

### **ETAPA 1: Prepara√ß√£o e Logs de Debug** ‚è±Ô∏è 15min

_Objetivo: Adicionar observabilidade sem quebrar nada_

#### 1.1 Adicionar Callback Props (Interface Only)

```typescript
// unified-chat-page.tsx - APENAS interface, sem implementa√ß√£o
interface UnifiedChatPageProps {
  sessionId?: string;
  locale: string;
  // ‚úÖ ETAPA 1: Adicionar prop opcional (n√£o quebra nada)
  onStreamingFinished?: () => void;
}

// chat-window.tsx - APENAS interface
interface ChatWindowProps {
  sessionId?: string;
  onNewSession?: (sessionId: string) => void;
  // ‚úÖ ETAPA 1: Adicionar prop opcional
  onStreamingFinished?: () => void;
}
```

#### 1.2 Logs de Monitoramento

```typescript
// model-info-badge.tsx - Adicionar logs espec√≠ficos
useEffect(() => {
  console.log("[MODEL_INFO_BADGE] ETAPA_1 - Estado atual:", {
    configuredModel,
    actualModel,
    hasModelMismatch,
    isCorrect,
    shouldUpdate: hasModelMismatch && !isCorrect,
    timestamp: new Date().toISOString(),
  });
}, [configuredModel, actualModel, hasModelMismatch, isCorrect]);
```

**‚úÖ Valida√ß√£o ETAPA 1:**

- C√≥digo compila sem erros
- Props opcionais n√£o quebram nada
- Logs mostram estado atual do badge

---

### **ETAPA 2: Implementar Callback Chain** ‚è±Ô∏è 20min

_Objetivo: Conectar useChat.onFinish ao badge_

#### 2.1 Implementar Handler no UnifiedChatPage

```typescript
// unified-chat-page.tsx
export function UnifiedChatPage({ sessionId, locale }: UnifiedChatPageProps) {
  // ‚úÖ ETAPA 2: Handler para streaming finished
  const handleStreamingFinished = useCallback(() => {
    console.log("üéâ [UNIFIED_CHAT] ETAPA_2 - Streaming finished, atualizando badge");

    // Force re-fetch espec√≠fico para badge
    if (selectedSessionId) {
      setTimeout(() => {
        messagesQuery.refetch();
        console.log("‚úÖ [UNIFIED_CHAT] ETAPA_2 - Badge data refreshed");
      }, 100); // Pequeno delay para garantir que backend processou
    }
  }, [selectedSessionId, messagesQuery]);

  return (
    // ... c√≥digo existente ...
    <ChatWindow
      sessionId={selectedSessionId}
      onNewSession={handleSessionSelect}
      onStreamingFinished={handleStreamingFinished} // ‚úÖ ETAPA 2: Passar callback
    />
  );
}
```

#### 2.2 Propagar Callback no ChatWindow

```typescript
// chat-window.tsx - ActiveChatWindow
function ActiveChatWindow({
  sessionId,
  onNewSession,
  onStreamingFinished, // ‚úÖ ETAPA 2: Receber callback
}: {
  sessionId: string;
  onNewSession?: (sessionId: string) => void;
  onStreamingFinished?: () => void; // ‚úÖ ETAPA 2: Tipar callback
}) {
  // ‚úÖ ETAPA 2: Modificar handleChatFinish existente
  const handleChatFinish = useCallback(
    async (message: any) => {
      if (process.env.NODE_ENV === "development") {
        console.log("‚úÖ [ACTIVE_CHAT] ETAPA_2 - Mensagem conclu√≠da:", message);
      }

      // ‚úÖ ETAPA 2: Notificar badge que streaming terminou
      onStreamingFinished?.();

      // Auto-focus ap√≥s streaming (c√≥digo existente)
      setTimeout(() => {
        inputRef.current?.focus();
      }, 100);

      // C√≥digo existente de sincroniza√ß√£o
      setTimeout(async () => {
        await syncNow();
        refetchSession();
        queryClient.invalidateQueries(
          trpc.app.chat.listarSessions.pathFilter(),
        );
      }, 1500);
    },
    [
      syncNow,
      refetchSession,
      queryClient,
      trpc.app.chat.listarSessions,
      onStreamingFinished,
    ], // ‚úÖ ETAPA 2: Adicionar dep
  );

  // useChat permanece igual, s√≥ o callback que mudou
}
```

**‚úÖ Valida√ß√£o ETAPA 2:**

- Callback √© chamado quando streaming termina
- Logs mostram "Streaming finished" no console
- Badge ainda pode n√£o atualizar (esperado)

---

### **ETAPA 3: For√ßar Re-render do Badge** ‚è±Ô∏è 15min

_Objetivo: Garantir que badge recalcula quando callback √© chamado_

#### 3.1 Adicionar Trigger State no UnifiedChatPage

```typescript
// unified-chat-page.tsx
export function UnifiedChatPage({ sessionId, locale }: UnifiedChatPageProps) {
  // ‚úÖ ETAPA 3: Estado para for√ßar re-render do badge
  const [badgeUpdateTrigger, setBadgeUpdateTrigger] = useState(0);

  const handleStreamingFinished = useCallback(() => {
    console.log("üéâ [UNIFIED_CHAT] ETAPA_3 - Streaming finished, triggering badge update");

    // ‚úÖ ETAPA 3: Incrementar trigger para for√ßar re-render
    setBadgeUpdateTrigger(prev => prev + 1);

    // Force re-fetch (c√≥digo da ETAPA 2)
    if (selectedSessionId) {
      setTimeout(() => {
        messagesQuery.refetch();
        console.log("‚úÖ [UNIFIED_CHAT] ETAPA_3 - Badge data refreshed");
      }, 100);
    }
  }, [selectedSessionId, messagesQuery]);

  return (
    // ... c√≥digo existente ...
    {/* Model Info Badge - apenas quando h√° sess√£o */}
    {selectedSessionId && sessionQuery.data && (
      <ModelInfoBadge
        key={`model-info-${selectedSessionId}-${selectedModelId}-${sessionQuery.data.aiModelId}-${badgeUpdateTrigger}`} // ‚úÖ ETAPA 3: Incluir trigger na key
        sessionData={sessionQuery.data}
        lastMessageMetadata={lastMessageMetadata}
      />
    )}
  );
}
```

**‚úÖ Valida√ß√£o ETAPA 3:**

- Badge re-monta quando trigger muda
- Logs mostram re-c√°lculo de status
- Badge deve come√ßar a atualizar corretamente

---

### **ETAPA 4: Otimizar Timing e Performance** ‚è±Ô∏è 15min

_Objetivo: Ajustar delays e memoiza√ß√£o_

#### 4.1 Ajustar Timing no Callback Chain

```typescript
// unified-chat-page.tsx
const handleStreamingFinished = useCallback(() => {
  console.log(
    "üéâ [UNIFIED_CHAT] ETAPA_4 - Streaming finished, optimized timing",
  );

  // ‚úÖ ETAPA 4: Timing otimizado baseado nas li√ß√µes
  setTimeout(() => {
    // Primeiro: atualizar trigger para re-render imediato
    setBadgeUpdateTrigger((prev) => prev + 1);

    // Segundo: re-fetch dados ap√≥s pequeno delay
    setTimeout(() => {
      messagesQuery.refetch();
      console.log(
        "‚úÖ [UNIFIED_CHAT] ETAPA_4 - Badge data refreshed with optimized timing",
      );
    }, 200); // ‚úÖ Delay otimizado baseado nas li√ß√µes
  }, 50); // ‚úÖ Delay m√≠nimo para garantir que useChat processou
}, [selectedSessionId, messagesQuery]);
```

#### 4.2 Memoizar Callback para Performance

```typescript
// chat-window.tsx
const handleChatFinish = useCallback(
  async (message: any) => {
    if (process.env.NODE_ENV === "development") {
      console.log(
        "‚úÖ [ACTIVE_CHAT] ETAPA_4 - Mensagem conclu√≠da (optimized):",
        message,
      );
    }

    // ‚úÖ ETAPA 4: Callback imediato (sem delay)
    onStreamingFinished?.();

    // Auto-focus e sync (c√≥digo existente com timing ajustado)
    setTimeout(() => {
      inputRef.current?.focus();
    }, 100);

    // ‚úÖ ETAPA 4: Timing otimizado para sync
    setTimeout(async () => {
      await syncNow();
      refetchSession();
      queryClient.invalidateQueries(trpc.app.chat.listarSessions.pathFilter());
    }, 1000); // ‚úÖ Reduzido de 1500ms para 1000ms
  },
  [
    syncNow,
    refetchSession,
    queryClient,
    trpc.app.chat.listarSessions,
    onStreamingFinished,
  ],
);
```

**‚úÖ Valida√ß√£o ETAPA 4:**

- Badge atualiza mais rapidamente
- Performance mantida
- Timing otimizado baseado nas li√ß√µes

---

### **ETAPA 5: Cleanup e Logs de Produ√ß√£o** ‚è±Ô∏è 10min

_Objetivo: Remover logs de debug e validar solu√ß√£o final_

#### 5.1 Remover Logs de Debug

```typescript
// model-info-badge.tsx - Manter apenas logs essenciais
useEffect(() => {
  if (process.env.NODE_ENV === "development") {
    console.log("[MODEL_INFO_BADGE] Status atualizado:", {
      isCorrect,
      isWaitingValidation,
      statusLabel: status.label,
    });
  }
}, [isCorrect, isWaitingValidation, status.label]);
```

#### 5.2 Valida√ß√£o Final

```typescript
// unified-chat-page.tsx - Log de sucesso final
const handleStreamingFinished = useCallback(() => {
  if (process.env.NODE_ENV === "development") {
    console.log("üéâ [MODEL_INFO_BADGE] Corre√ß√£o aplicada com sucesso!");
  }

  // C√≥digo otimizado da ETAPA 4
  setTimeout(() => {
    setBadgeUpdateTrigger((prev) => prev + 1);
    setTimeout(() => {
      messagesQuery.refetch();
    }, 200);
  }, 50);
}, [selectedSessionId, messagesQuery]);
```

**‚úÖ Valida√ß√£o ETAPA 5:**

- Badge funciona perfeitamente
- Logs limpos para produ√ß√£o
- Zero breaking changes confirmado

## üîí Garantias de Seguran√ßa

### **Anti-Breaking Changes:**

1. **Props opcionais** - n√£o quebra componentes existentes
2. **Callback chain** - apenas adiciona funcionalidade
3. **Backward compatibility** - funciona sem callbacks
4. **Gradual rollout** - cada etapa √© valid√°vel independentemente

### **Rollback Plan:**

- **ETAPA 1-2:** Remover props opcionais
- **ETAPA 3-4:** Remover trigger state
- **ETAPA 5:** Reverter para estado anterior

### **Monitoring:**

- Logs estruturados em cada etapa
- Valida√ß√£o de funcionamento em cada step
- Performance tracking

## üìä Crit√©rios de Sucesso

### **Funcionais:**

- [ ] Badge mostra ‚è± quando modelo √© mudado
- [ ] Badge mostra ‚úì instantaneamente ap√≥s streaming terminar
- [ ] Sem necessidade de refresh manual
- [ ] Funciona em m√∫ltiplas mudan√ßas consecutivas

### **T√©cnicos:**

- [ ] Zero breaking changes
- [ ] Performance mantida ou melhorada
- [ ] Logs limpos em produ√ß√£o
- [ ] C√≥digo bem documentado

### **UX:**

- [ ] Feedback visual imediato
- [ ] Transi√ß√µes suaves
- [ ] Confian√ßa na interface restaurada

## üöÄ Execu√ß√£o

### **Ordem de Implementa√ß√£o:**

1. **ETAPA 1** ‚Üí Validar ‚Üí Commit
2. **ETAPA 2** ‚Üí Validar ‚Üí Commit
3. **ETAPA 3** ‚Üí Validar ‚Üí Commit
4. **ETAPA 4** ‚Üí Validar ‚Üí Commit
5. **ETAPA 5** ‚Üí Validar ‚Üí Commit final

### **Tempo Estimado:**

- **Total:** 75 minutos
- **Por etapa:** 15-20 minutos
- **Valida√ß√£o:** 5 minutos por etapa

### **Depend√™ncias:**

- ‚úÖ Arquitetura atual preservada
- ‚úÖ useChat onFinish callback dispon√≠vel
- ‚úÖ Callback chain pattern estabelecido

---

**üéØ Resultado Esperado:** Model Info Badge funcionando perfeitamente com atualiza√ß√£o instant√¢nea ap√≥s streaming, sem quebrar nada na arquitetura existente.

**üìö Baseado em:** Li√ß√µes aprendidas de debugging anterior, padr√µes estabelecidos e arquitetura thread-first atual.

---
