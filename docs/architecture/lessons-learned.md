# üìñ Li√ß√µes Aprendidas de Arquitetura - Kodix

**Data de Cria√ß√£o:** 2025-01-13  
**Status:** Documento vivo. Adicione novas li√ß√µes ap√≥s cada incidente ou descoberta relevante.

## üéØ Objetivo

Este documento centraliza as **li√ß√µes cr√≠ticas aprendidas** durante o desenvolvimento do projeto Kodix. Seu prop√≥sito √© servir como um guia pr√°tico para prevenir a repeti√ß√£o de erros, melhorar a qualidade do c√≥digo e garantir a estabilidade da arquitetura em todo o monorepo.

A leitura deste documento √© **obrigat√≥ria** para todos os desenvolvedores.

---

## üìö Li√ß√µes Cr√≠ticas de Implementa√ß√£o

### **1. A Causa Raiz de Erros de Tipo em tRPC: Estrutura do Router**

- **Li√ß√£o**: Erros de infer√™ncia de tipo em cascata no frontend (como `Property 'mutate' does not exist` ou `Property 'queryOptions' is undefined`) s√£o quase sempre sintoma de um problema na **estrutura do router no backend**.
- **O Problema**: O cliente tRPC (`useTRPC`) n√£o conseguia inferir os tipos corretos para os procedures do Chat, tratando-os como `any` ou `undefined` e causando mais de 500 erros de "unsafe" no frontend.
- **Causa Raiz**: O `chatRouter` (e outros sub-routers) estava sendo exportado como um objeto TypeScript gen√©rico (`TRPCRouterRecord`) em vez de ser constru√≠do com a fun√ß√£o `t.router({...})` do tRPC. Isso apagava as informa√ß√µes de tipo detalhadas antes que chegassem ao router principal.
- **A√ß√£o Preventiva**: **TODOS** os routers, em todos os n√≠veis, devem ser constru√≠dos e exportados usando a fun√ß√£o `t.router({...})`. O uso de tipos gen√©ricos como `TRPCRouterRecord` √© proibido, pois quebra a infer√™ncia de tipos end-to-end.

  ```diff
  // ‚ùå ANTES: Apaga os tipos detalhados.
  import type { TRPCRouterRecord } from "@trpc/server";
  export const chatRouter: TRPCRouterRecord = { /* ... */ };

  // ‚úÖ DEPOIS: Preserva e propaga os tipos corretamente.
  import { t } from "../../../trpc";
  export const chatRouter = t.router({ /* ... */ });
  ```

### **2. A Refatora√ß√£o de Nomes N√ÉO √© Apenas Nominal**

- **Li√ß√£o**: Ao renomear um endpoint, a valida√ß√£o mais cr√≠tica √© garantir que o **contrato da API (formato do objeto de retorno)** e a **l√≥gica de consumo no frontend** permane√ßam perfeitamente sincronizados.
- **O Problema**: Uma refatora√ß√£o de `listarSessions` para `findSessions` passou nos testes, mas quebrou a UI porque o c√≥digo do frontend foi alterado para consumir `allSessionsQuery.data` (o objeto de pagina√ß√£o) em vez de `allSessionsQuery.data.sessions` (o array).
- **A√ß√£o Preventiva**: Em qualquer refatora√ß√£o de API, o `git diff` deve ser feito tanto no backend quanto no frontend, focando especificamente em como os dados retornados s√£o processados.

### **3. Testes de UI S√£o Essenciais para Prevenir Regress√µes Visuais**

- **Li√ß√£o**: Testes de unidade e `pnpm typecheck` s√£o essenciais, mas insuficientes para garantir que a interface do usu√°rio funcione como esperado.
- **O Problema**: O bug das sess√µes n√£o aparecendo na tela n√£o foi detectado pela su√≠te de testes existente.
- **A√ß√£o Preventiva**: Implementar testes de UI (end-to-end ou de integra√ß√£o visual) para cen√°rios cr√≠ticos. Ex: "Dado um mock de API com 5 sess√µes, a sidebar deve renderizar 5 itens".

### **4. Antipadr√£o: N+1 Queries em Componentes de Lista**

- **Li√ß√£o**: Componentes filhos renderizados em um loop (`.map()`) **n√£o devem** fazer suas pr√≥prias chamadas de API. A responsabilidade de buscar dados deve ser do componente pai.
- **O Problema**: O `FolderItem` fazia sua pr√≥pria chamada de API para buscar sess√µes, causando m√∫ltiplas queries desnecess√°rias e introduzindo bugs.
- **A√ß√£o Preventiva**: O componente pai (`AppSidebar`) deve buscar **todos** os dados necess√°rios de uma vez, process√°-los (agrupar) e passar os subconjuntos relevantes para os componentes filhos via props.

### **5. Proibi√ß√£o Estrita de `// @ts-nocheck`**

- **Li√ß√£o**: O coment√°rio `// @ts-nocheck` √© um anti-padr√£o perigoso que esconde problemas reais e leva a erros em tempo de execu√ß√£o.
- **O Problema**: O uso de `@ts-nocheck` em arquivos como `chat-thread-provider.tsx` mascarou dezenas de erros de tipo, que contribu√≠ram para a instabilidade geral.
- **A√ß√£o Preventiva**: `// @ts-nocheck` √© **estritamente proibido**. O problema de tipo subjacente deve ser sempre investigado e corrigido na sua causa raiz. A regra de linter `@typescript-eslint/ban-ts-comment` deve ser tratada como um erro bloqueante.

### **6. Preven√ß√£o de Erros de TypeScript em Modifica√ß√µes Cross-Package**

- **Li√ß√£o**: Modifica√ß√µes que afetam m√∫ltiplos packages no monorepo requerem uma estrat√©gia espec√≠fica para evitar erros de tipo persistentes e problemas de compila√ß√£o em cascata.
- **O Problema**: Durante a implementa√ß√£o de novas features que modificam schemas compartilhados (como `AppIdsWithUserAppTeamConfig`), ocorrem erros de tipo que persistem mesmo ap√≥s as corre√ß√µes, devido a problemas de cache e ordem de compila√ß√£o.
- **Sintomas Comuns**:
  - Erro: "Spread types may only be created from object types" em opera√ß√µes de spread
  - TypeScript n√£o reconhece novos valores em union types
  - Imports funcionam no IDE mas falham no build
  - `pnpm typecheck` passa mas `pnpm build` falha
- **A√ß√µes Preventivas**:

  1. **Ordem Correta de Implementa√ß√£o e Build**:

     ```bash
     # Ordem obrigat√≥ria de modifica√ß√£o e build:
     1. @kdx/shared (schemas e tipos base)
     2. @kdx/validators (valida√ß√µes de input/output)
     3. @kdx/db (reposit√≥rios e mapeamentos)
     4. @kdx/api (endpoints tRPC)
     5. Apps (frontend)

     # Comando correto ap√≥s cada modifica√ß√£o de tipo:
     pnpm build --filter=@kdx/shared --filter=@kdx/validators --filter=@kdx/db
     ```

  2. **Verifica√ß√£o Incremental Obrigat√≥ria**:

     ```bash
     # Ap√≥s CADA modifica√ß√£o de schema/tipo:
     pnpm typecheck
     # Se houver erros, N√ÉO continue com outras modifica√ß√µes
     ```

  3. **Limpeza de Cache do TypeScript**:

     ```bash
     # Se erros de tipo persistem ap√≥s corre√ß√µes:
     rm -rf node_modules/.cache
     pnpm install
     pnpm build --filter=@kdx/shared --force
     ```

  4. **Estrat√©gia de Modifica√ß√£o At√¥mica**:

     - Modifique UM package por vez
     - Fa√ßa build do package modificado
     - Verifique types antes de prosseguir
     - Commite incrementalmente (facilita rollback)

  5. **Padr√£o de Import Correto em tRPC**:

     ```typescript
     // ‚ùå ERRADO: Import de barril pode causar problemas
     import { protectedProcedure, router } from "../../../trpc";

     // ‚úÖ CORRETO: Imports espec√≠ficos
     import { protectedProcedure } from "../../../procedures";
     import { t } from "../../../trpc";
     ```

  6. **Valida√ß√£o Final Completa**:
     ```bash
     # Antes de considerar a feature completa:
     pnpm clean && pnpm install && pnpm typecheck && pnpm build
     ```

- **Dica de Ouro**: Se voc√™ est√° modificando tipos que s√£o usados em m√∫ltiplos packages, sempre fa√ßa um "build graph mental" antes de come√ßar. Pergunte-se: "Quais packages dependem deste tipo?" e compile-os na ordem correta.

### **7. Composi√ß√£o de Routers tRPC com `mergeRouters`**

- **Li√ß√£o**: A tentativa de combinar m√∫ltiplos sub-routers dentro de um √∫nico `t.router({ ...routerA, ...routerB })` usando spread syntax (`...`) resulta em erros de tipo complexos (`TS2345: Argument of type '...' is not assignable to parameter of type 'CreateRouterOptions'`).
- **O Problema**: O `t.router()` foi projetado para aceitar um objeto de _procedures_, n√£o de _routers_. A sintaxe de spread funciona para mesclar objetos de procedures, mas falha ao tentar mesclar inst√¢ncias de routers completos, pois suas estruturas internas (`_def`) s√£o incompat√≠veis.
- **A√ß√£o Preventiva**: Use a fun√ß√£o `t.mergeRouters(...routers)` para combinar m√∫ltiplos routers. Se voc√™ precisar adicionar procedures avulsos junto com sub-routers, agrupe os procedures avulsos em seu pr√≥prio `t.router` e depois mescle tudo.

  ```typescript
  // ‚ùå ANTES: Causa erro de tipo.
  const finalRouter = t.router({
    ...subRouterA,
    ...subRouterB,
    procedureC: protectedProcedure.query(() => {
      /*...*/
    }),
  });

  // ‚úÖ DEPOIS: Padr√£o correto e seguro.
  const rootProcedures = t.router({
    procedureC: protectedProcedure.query(() => {
      /*...*/
    }),
  });

  const finalRouter = t.mergeRouters(subRouterA, subRouterB, rootProcedures);
  ```

### **8. O Efeito Cascata de Constantes Globais (App IDs)**

- **Li√ß√£o**: Adicionar uma nova constante de ID global (ex: um novo `cupomAppId` em `@kdx/shared`) n√£o √© uma mudan√ßa isolada. √â o in√≠cio de uma cadeia de modifica√ß√µes necess√°rias em todo o monorepo.
- **O Problema**: A adi√ß√£o de `cupomAppId` causou uma s√©rie de erros de compila√ß√£o em m√∫ltiplos pacotes (`@kdx/db`, `@kdx/permissions`, `@kdx/locales`), pois diversos objetos de mapeamento (`appIdToSchemas`, `appIdToPermissionsFactory`, `appIdToName`, etc.) se tornaram incompletos e, portanto, inv√°lidos do ponto de vista do TypeScript.
- **A√ß√£o Preventiva**: Ao adicionar uma nova constante de ID que √© parte de um tipo `union` (como `KodixAppId`), use a busca global do editor para encontrar **todas** as ocorr√™ncias do tipo e dos objetos de mapeamento relacionados (`Record<KodixAppId, ...>`). Atualize cada um deles antes de tentar compilar o projeto. Trate a adi√ß√£o de um ID como uma refatora√ß√£o em todo o sistema, n√£o como uma mudan√ßa em um √∫nico arquivo.

### **9. Fluxo de Inicializa√ß√£o Robusto do Servidor**

- **Li√ß√£o**: Scripts que apenas verificam se uma porta est√° em uso (`check-dev-status.sh`) s√£o insuficientes e podem levar a loops infinitos se o servidor falhar em compilar.
- **O Problema**: O script `check-dev-status.sh` ficava "preso", aguardando um servidor que nunca iniciaria porque havia um erro de compila√ß√£o em um pacote dependente que impedia o `pnpm dev:kdx` de concluir.
- **A√ß√£o Preventiva**: Adotar um fluxo de inicializa√ß√£o em m√∫ltiplos est√°gios que prioriza a detec√ß√£o de erros.
  1.  `sh ./scripts/stop-dev.sh` (Garante um ambiente limpo)
  2.  `sh ./scripts/start-dev-bg.sh` (Inicia em segundo plano)
  3.  `sleep 5` (Aguarda a gera√ß√£o de logs)
  4.  `sh ./scripts/check-log-errors.sh` (**Passo cr√≠tico: verifica erros de build primeiro**)
  5.  `sh ./scripts/check-dev-status.sh` (Verifica se o servidor est√° rodando, **somente se n√£o houver erros**)
- **Refer√™ncia:** Este fluxo agora est√° documentado em `docs/scripts/README.md`.

### **10. Configura√ß√£o Robusta de Testes (Vitest) no Monorepo**

- **Li√ß√£o**: A configura√ß√£o de testes em um monorepo com Vitest possui particularidades que, se n√£o tratadas corretamente, levam a erros de inicializa√ß√£o.
- **O Problema 1**: Erro `Cannot find module ...` com caminhos duplicados (ex: `packages/api/packages/api/...`).
  - **Causa Raiz**: `vitest.config.ts` na raiz do projeto usava caminhos relativos para `setupFiles`. O Vitest resolve esses caminhos a partir do diret√≥rio do pacote em teste, n√£o da raiz, duplicando o caminho.
  - **A√ß√£o Preventiva**: Sempre use caminhos absolutos para `setupFiles` na configura√ß√£o raiz do Vitest.
    ```typescript
    // vitest.config.ts
    import path from "path";
    // ...
    setupFiles: [
      path.resolve(__dirname, "./packages/api/src/test-setup.ts"),
    ],
    ```
- **O Problema 2**: Erro `ReferenceError: Cannot access '...' before initialization` ao usar `vi.mock`.
  - **Causa Raiz**: `vi.mock` √© "i√ßado" (hoisted) para o topo do arquivo durante a compila√ß√£o, sendo executado antes da declara√ß√£o de outras vari√°veis no escopo do m√≥dulo. Se a f√°brica do mock (`() => ({...})`) referencia uma vari√°vel declarada depois, ela ainda n√£o foi inicializada.
  - **A√ß√£o Preventiva**: Sempre declare as vari√°veis ou constantes que ser√£o usadas dentro de uma f√°brica de `vi.mock` **antes** da chamada ao `vi.mock`.

### **11. Estrutura de Pacotes vs. Automa√ß√£o e Hooks de Valida√ß√£o**

- **Li√ß√£o**: A cria√ß√£o manual ou automatizada de pacotes deve ser consistente com os hooks de valida√ß√£o do projeto (ex: `sherif` para ordena√ß√£o de `package.json`).
- **O Problema**: Ao criar o pacote `@kdx/core-engine` manualmente, o `pnpm install` falhou com um erro do `sherif` porque as depend√™ncias no `package.json` n√£o estavam em ordem alfab√©tica.
- **A√ß√£o Preventiva**: Ao criar um novo pacote, garanta que todas as chaves nos arquivos de configura√ß√£o, especialmente as `dependencies` e `devDependencies` no `package.json`, sigam a ordem alfab√©tica exigida pelos linters do projeto. Isso se aplica tanto a geradores de c√≥digo (`turbo gen`) quanto √† cria√ß√£o manual.

### **12. Resolu√ß√£o de M√≥dulos em Workspace (Imports de Sub-path)**

- **Li√ß√£o**: Imports de sub-paths de pacotes do workspace (ex: `from "@kdx/db/repositories"`) s√£o um anti-padr√£o perigoso. Eles podem funcionar no editor (devido √† intelig√™ncia do VSCode), mas falham durante o build do TypeScript ou com o Turborepo.
- **O Problema**: A tentativa de importar o `appRepository` de `@kdx/db/repositories` dentro do novo pacote `@kdx/core-engine` falhou, pois a configura√ß√£o de `moduleResolution: "Bundler"` espera que os imports apontem apenas para o ponto de entrada definido no `exports` do `package.json` do pacote alvo.
- **A√ß√£o Preventiva**: **TODOS** os imports entre pacotes do workspace **DEVEM** apontar para o ponto de entrada principal (ex: `from "@kdx/db"`). Para que isso funcione, o pacote alvo (`@kdx/db` neste caso) deve exportar explicitamente os membros desejados (como `appRepository`) em seu `index.ts` principal.

### **13. Configura√ß√£o de Testes de Pacotes e Depend√™ncias de Desenvolvimento**

- **Li√ß√£o**: A aus√™ncia de um script de teste padronizado e de depend√™ncias de desenvolvimento expl√≠citas (`devDependencies`) em um pacote pode levar a falhas de CI e a um fluxo de trabalho de teste inconsistente.
- **O Problema**: Ao tentar testar o pacote `@kdx/core-engine`, o comando `pnpm test --filter=@kdx/core-engine` falhou porque o `package.json` n√£o continha um script `test`, e `vitest` n√£o estava listado como uma `devDependency`, exigindo o uso de `npx vitest`, que depende de uma instala√ß√£o global ou no root.
- **A√ß√£o Preventiva**: Para garantir que cada pacote seja aut√¥nomo e test√°vel de forma padronizada, **TODOS** os pacotes que cont√™m testes **DEVEM**:
  1.  Incluir `vitest` e outras depend√™ncias de teste relevantes (ex: `@vitest/coverage-v8`) em suas `devDependencies` no `package.json`.
  2.  Definir um script `test` em seu `package.json`, padronizado como `"test": "vitest run"`.

### **14. Precis√£o em Mocks de Testes com Tipagem Forte (Zod)**

- **Li√ß√£o**: Em um ecossistema com tipagem forte como o nosso, mockar dados para testes vai al√©m de simplesmente simular uma fun√ß√£o; √© preciso garantir que a **estrutura e os tipos dos dados mockados** correspondam perfeitamente aos schemas Zod.
- **O Problema**: Testes para o `ConfigurationService` falharam repetidamente com erros de tipo do Zod porque os objetos de mock para os reposit√≥rios n√£o inclu√≠am todas as propriedades obrigat√≥rias (ex: `appliesTo` em um objeto de configura√ß√£o) ou n√£o correspondiam √† estrutura de retorno esperada pelas fun√ß√µes do reposit√≥rio.
- **A√ß√£o Preventiva**: Ao escrever testes que mockam uma camada de dados:
  1.  **Importe os schemas Zod** relevantes (`*ConfigSchema`) no arquivo de teste.
  2.  **Use o schema para validar seu mock** ou, idealmente, use uma factory para gerar mocks a partir do schema, garantindo 100% de conformidade.
  3.  **Verifique a estrutura de retorno completa**, n√£o apenas o `config`. Se a fun√ß√£o retorna `[{ config: {...}, teamId: '...' }]`, o mock deve ter essa estrutura exata.

### **15. An√°lise de Erros de Ambiente vs. Erros de C√≥digo**

- **Li√ß√£o**: Nem todo erro exibido pelo `check-log-errors.sh` √© bloqueante para a tarefa em quest√£o. √â crucial diferenciar entre **erros de compila√ß√£o do c√≥digo em que se est√° trabalhando** e **erros de servi√ßos perif√©ricos do ambiente** (ex: Docker, Redis).
- **O Problema**: Um erro `exit code 125` do `@kdx/db-dev` (Docker) apareceu nos logs. Uma interpreta√ß√£o apressada poderia levar √† interrup√ß√£o da tarefa, assumindo que o ambiente estava quebrado.
- **A√ß√£o Preventiva**: Ao analisar erros de log, siga este fluxo:
  1.  **Identifique a Origem:** O log de erro vem do pacote que voc√™ est√° modificando ou de um servi√ßo de suporte?
  2.  **Verifique o Impacto Real:** Ap√≥s o `check-log-errors.sh`, sempre continue o fluxo executando `sh ./scripts/check-dev-status.sh`. Se o servidor principal (`apps/kdx`) estiver `RUNNING`, o erro de ambiente provavelmente n√£o √© cr√≠tico para a sua tarefa e pode ser tratado separadamente.

### **16. Chamadas de Service Layer a partir de Contextos n√£o-tRPC (API Routes)**

- **Li√ß√£o**: Um Service Layer que depende de um contexto tRPC (`ctx`) n√£o pode ser chamado diretamente de um endpoint Next.js API Route, pois este n√£o possui o `ctx`.
- **O Problema**: A tentativa de chamar `AiStudioService.getSystemPrompt(ctx, ...)` de dentro de `/api/chat/stream/route.ts` falhou porque a vari√°vel `ctx` n√£o existia naquele escopo.
- **Causa Raiz**: As API Routes do Next.js e os procedures do tRPC operam em contextos diferentes. O `ctx` do tRPC √© constru√≠do por um middleware espec√≠fico que n√£o √© executado em uma API Route padr√£o.
- **A√ß√£o Preventiva**: Quando for necess√°rio chamar um servi√ßo dependente de `ctx` de fora de um procedure tRPC, o contexto deve ser reconstru√≠do manualmente dentro do chamador. Isso envolve importar e usar as mesmas primitivas (`auth()`, `createTRPCContext`) que o tRPC usa para criar seu contexto original.

  ```typescript
  // ‚úÖ CORRETO: Reconstruindo o contexto em uma API Route
  import { auth } from "@kdx/auth";
  import { createTRPCContext } from "@kdx/api";

  export async function POST(request: NextRequest) {
    // ...
    const authResult = await auth();
    const ctx = await createTRPCContext({
      auth: authResult,
      headers: request.headers,
    });

    // Agora o servi√ßo pode ser chamado com o contexto correto
    const result = await AiStudioService.getSystemPrompt({ ctx, params: {...} });
    // ...
  }
  ```

### **17. Interfer√™ncia de Tipagem em Ambientes de Teste (Vitest)**

- **Li√ß√£o**: Constantes exportadas com `as const` podem, em alguns casos, ter seu tipo literal inferido como um `string` gen√©rico dentro do ambiente de teste do Vitest, causando erros de tipo inesperados.
- **O Problema**: A constante `chatAppId` (do tipo literal `"az1x2c3bv4n5"`) era passada para uma fun√ß√£o que esperava o tipo `KodixAppId` (uma uni√£o de tipos literais). Embora o c√≥digo estivesse correto, o Vitest acusava um erro de que `string` n√£o era atribu√≠vel a `KodixAppId`.
- **Causa Raiz**: O sistema de m√≥dulos ou o bundler do Vitest pode, em certas configura√ß√µes, "perder" a informa√ß√£o do tipo literal durante o processo de transpila√ß√£o/mocking, tratando a constante como uma `string` comum.
- **A√ß√£o Preventiva**: Quando encontrar erros de tipo persistentes e aparentemente incorretos em testes, onde um valor literal n√£o bate com um tipo `union` correspondente, use um type cast expl√≠cito (`as`) como uma solu√ß√£o pragm√°tica para for√ßar o compilador a aceitar o tipo correto.

  ```typescript
  // ‚úÖ SOLU√á√ÉO PRAGM√ÅTICA: Type cast no arquivo de teste
  import type { KodixAppId } from "@kdx/shared";
  import { chatAppId } from "@kdx/shared";

  const mockParams = {
    // ...
    requestingApp: chatAppId as KodixAppId, // For√ßa a tipagem correta
  };
  ```

### **18. O Efeito Cascata de Refatora√ß√µes e a Import√¢ncia da Busca Global**

- **Li√ß√£o**: A remo√ß√£o ou renomea√ß√£o de uma fun√ß√£o ou servi√ßo frequentemente causa uma cascata de erros de compila√ß√£o em locais inesperados do monorepo. Confiar apenas no compilador para encontrar todos os erros pode ser lento e ineficiente.
- **O Problema**: Ap√≥s refatorar e remover `getSystemPromptForChat` e `getTeamInstructions` do `AiStudioService`, o build falhou m√∫ltiplas vezes porque v√°rios handlers e testes ainda continham chamadas para os m√©todos antigos.
- **Causa Raiz**: Falha em identificar proativamente todos os pontos de uso (call sites) da funcionalidade que estava sendo refatorada antes de iniciar a remo√ß√£o.
- **A√ß√£o Preventiva**: Antes de remover ou renomear uma fun√ß√£o exportada, **SEMPRE** execute uma busca global (usando a busca do editor ou `grep`) pelo nome da fun√ß√£o. Analise cada ocorr√™ncia e inclua a atualiza√ß√£o de todos os arquivos afetados no plano de refatora√ß√£o. Isso transforma a descoberta de erros de reativa (esperar o build falhar) para proativa (mapear o impacto completo antecipadamente).

---

<!-- Teste de edi√ß√£o at√¥mica. -->

Este documento deve ser o primeiro lugar a ser consultado ao encontrar um bug inesperado e o √∫ltimo a ser atualizado ap√≥s a resolu√ß√£o, garantindo que o conhecimento da equipe evolua constantemente.

<!-- Teste de edi√ß√£o at√¥mica. -->

### **19. Teste de Bloco Pequeno**

- **Li√ß√£o**: Testando a adi√ß√£o de um bloco pequeno de markdown.
- **A√ß√£o Preventiva**: Dividir edi√ß√µes grandes em partes menores.
